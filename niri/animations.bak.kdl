animations {
    // off
    // slowdown 100.0
    // slowdown 10.0
    // slowdown 4.0
    // slowdown 3.0
    // slowdown 2.0
    // slowdown 1.5

    workspace-switch {
        // off
        // duration-ms 2500
        // curve "ease-out-cubic"
        spring damping-ratio=0.8 stiffness=200 epsilon=0.0001
    }

    window-open {
        // off
        duration-ms 400
        curve "ease-out-cubic"
        // spring damping-ratio=0.8 stiffness=1000 epsilon=0.0001
        // duration-ms 1000
        // curve "linear"


    // expand and translate downwards
        custom-shader r"
float map(float value, float min1, float max1, float min2, float max2) {
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec4 open_color(vec3 coords_geo, vec3 size_geo) {
    float cur = niri_clamped_progress;
    vec3 coord = vec3(
        coords_geo.x,
        map(coords_geo.y, 0.0, cur, 0.0, 1.0),
        coords_geo.z
    );
    coord.y += 1.0 * (1.0 - cur);
    return texture2D(niri_tex, (niri_geo_to_tex * coord).st);
}
"
        // custom-shader r"
        //     vec4 open_color(vec3 coords_geo, vec3 size_geo) {
        //         vec3 coords_tex = niri_geo_to_tex * coords_geo;
        //         vec4 color = texture2D(niri_tex, coords_tex.st);
        //
        //         vec2 coords = (coords_geo.xy - vec2(0.5, 0.5)) * size_geo.xy * 2.0;
        //         coords = coords / length(size_geo.xy);
        //         float p = niri_clamped_progress;
        //         if (p * p <= dot(coords, coords))
        //             color = vec4(0.0);
        //
        //         return color;
        //     }
        // "

        // custom-shader r"
        //     vec4 open_color(vec3 coords_geo, vec3 size_geo) {
        //         // Scale up the window.
        //         float scale = max(0.0, (niri_progress / 2.0 + 0.5));
        //         coords_geo = vec3((coords_geo.xy - vec2(0.5)) / scale + vec2(0.5), 1.0);
        //
        //         // Get color from the window texture.
        //         vec3 coords_tex = niri_geo_to_tex * coords_geo;
        //         vec4 color = texture2D(niri_tex, coords_tex.st);
        //
        //         // Make the window opaque.
        //         color *= niri_clamped_progress;
        //
        //         return color;
        //     }
        // "
        // custom-shader r"
        //     vec4 open_color(vec3 coords_geo, vec3 size_geo) {
        //         vec3 coords_tex = niri_geo_to_tex * coords_geo;
        //         vec4 color = texture2D(niri_tex, coords_tex.st);
        //
        //         return color;
        //     }
        // "
    }

    window-close {
        // off
        // duration-ms 2500
        // duration-ms 3000
        duration-ms 400
        // spring damping-ratio=0.8 stiffness=100 epsilon=0.001
        // spring damping-ratio=1.0 stiffness=800 epsilon=0.0001

    // collapse and translate downwards
        custom-shader r"
float map(float value, float min1, float max1, float min2, float max2) {
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec4 close_color(vec3 coords_geo, vec3 size_geo) {
    float cur = niri_clamped_progress;
    vec3 coord = vec3(
        coords_geo.x,
        // 0.2,
        map(coords_geo.y, cur, 1.0, 0.0, 1.0),
        coords_geo.z
    );
    coord.y -= 1.0 * cur;
    return texture2D(niri_tex, (niri_geo_to_tex * coord).st);
}
        "

//         custom-shader r"
// vec4 fall_and_rotate(vec3 coords_geo, vec3 size_geo) {
//     float progress = niri_clamped_progress * niri_clamped_progress;
//     vec2 coords = (coords_geo.xy - vec2(0.5, 1.0)) * size_geo.xy;
//     coords.y -= progress * 200.0;
//     float random = (niri_random_seed - 0.5) / 2.0;
//     random = sign(random) - random;
//     float max_angle = 0.05 * random;
//     float angle = progress * max_angle;
//     mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
//     coords = rotate * coords;
//     coords_geo = vec3(coords / size_geo.xy + vec2(0.5, 1.0), 1.0);
//     vec3 coords_tex = niri_geo_to_tex * coords_geo;
//     vec4 color = texture2D(niri_tex, coords_tex.st);
//     return color * (1.0 - niri_clamped_progress);
// }
// vec4 close_color(vec3 coords_geo, vec3 size_geo) {
//     // You can pick one of the example functions or write your own.
//     return fall_and_rotate(coords_geo, size_geo);
// }
//         "

        /-custom-shader r"
            vec4 close_color(vec3 coords_geo, vec3 size_geo) {
                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                return color;
            }
        "
    }

    horizontal-view-movement {
        // off
        // duration-ms 500
        // curve "ease-out-cubic"
        spring damping-ratio=1.0 stiffness=300 epsilon=0.00001
        // spring damping-ratio=10.0 stiffness=800 epsilon=0.0001
    }

    window-movement {
        // off
        // duration-ms 750
        // curve "ease-out-cubic"
        spring damping-ratio=1.0 stiffness=200 epsilon=0.00001
        // spring damping-ratio=0.2 stiffness=800 epsilon=0.0001
    }

    /-window-resize {
        // off
        // duration-ms 500
        // duration-ms 2500
        // curve "ease-out-cubic"
        // spring damping-ratio=0.2 stiffness=800 epsilon=0.0001
    }

    config-notification-open-close {
        // off
        // duration-ms 250
        // curve "ease-out-cubic"
        // spring damping-ratio=0.1 stiffness=1000 epsilon=0.001
    }

    /-screenshot-ui-open {
        // off
        // duration-ms 200
        // curve "ease-out-quad"
    }
}
